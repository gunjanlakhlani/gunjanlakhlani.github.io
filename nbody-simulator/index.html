<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravitational N-Body Simulator | Gunjan Lakhlani</title>
    <meta name="description"
        content="Interactive gravitational N-body simulator — place bodies, set velocities, and watch gravity do its thing. Built with HTML5 Canvas.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        /* ─── Reset & Base ─────────────────────────────────────── */
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a1a;
            --bg-secondary: #0f0f24;
            --bg-panel: #12122a;
            --bg-hover: #1a1a3a;
            --border: rgba(255, 255, 255, 0.06);
            --border-active: rgba(120, 160, 255, 0.3);
            --text-primary: #e8e8f0;
            --text-secondary: #a0a0b8;
            --text-muted: #606080;
            --accent: #7c8aff;
            --accent-glow: rgba(124, 138, 255, 0.15);
            --red: #ff6b6b;
            --teal: #4ecdc4;
            --gold: #ffe66d;
            --mint: #a8e6cf;
            --pink: #ff8b94;
            --purple: #6c5ce7;
            --orange: #fdcb6e;
            --green: #00b894;
            --radius: 8px;
            --radius-lg: 12px;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        /* ─── Layout ───────────────────────────────────────────── */
        .app {
            display: grid;
            grid-template-rows: auto 1fr;
            grid-template-columns: 320px 1fr;
            height: 100vh;
        }

        /* ─── Nav ──────────────────────────────────────────────── */
        .nav {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }

        .nav__brand {
            font-family: var(--font-mono);
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-decoration: none;
            letter-spacing: 0.03em;
            transition: color 0.2s;
        }

        .nav__brand:hover {
            color: var(--accent);
        }

        .nav__title {
            font-weight: 600;
            font-size: 1rem;
            background: linear-gradient(135deg, var(--accent), var(--teal));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav__links {
            display: flex;
            gap: 1.25rem;
        }

        .nav__links a {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-muted);
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: color 0.2s;
        }

        .nav__links a:hover {
            color: var(--text-primary);
        }

        /* ─── Sidebar ──────────────────────────────────────────── */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1rem;
        }

        .panel__title {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 0.75rem;
        }

        /* ─── Preset Buttons ───────────────────────────────────── */
        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .preset-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text-secondary);
            font-family: var(--font-mono);
            font-size: 0.72rem;
            padding: 0.6rem 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .preset-btn:hover {
            border-color: var(--border-active);
            color: var(--text-primary);
            background: rgba(124, 138, 255, 0.08);
        }

        .preset-btn.active {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        .preset-btn .preset-icon {
            display: block;
            font-size: 1.2rem;
            margin-bottom: 0.3rem;
        }

        /* ─── Controls ─────────────────────────────────────────── */
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.6rem;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-family: var(--font-mono);
            font-size: 0.72rem;
            color: var(--text-muted);
        }

        .control-value {
            font-family: var(--font-mono);
            font-size: 0.72rem;
            color: var(--accent);
            min-width: 50px;
            text-align: right;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--bg-hover);
            border-radius: 2px;
            outline: none;
            margin-top: 0.4rem;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        /* ─── Action Buttons ───────────────────────────────────── */
        .actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            flex: 1;
            padding: 0.65rem 0.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: var(--bg-hover);
            color: var(--text-secondary);
            font-family: var(--font-mono);
            font-size: 0.72rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .btn--primary {
            background: rgba(124, 138, 255, 0.15);
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn--primary:hover {
            background: rgba(124, 138, 255, 0.25);
        }

        .btn--danger {
            border-color: rgba(255, 107, 107, 0.3);
            color: var(--red);
        }

        .btn--danger:hover {
            background: rgba(255, 107, 107, 0.1);
            border-color: var(--red);
        }

        /* ─── Stats ────────────────────────────────────────────── */
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-family: var(--font-mono);
            font-size: 0.68rem;
            color: var(--text-muted);
        }

        .stat-value {
            font-family: var(--font-mono);
            font-size: 0.72rem;
            color: var(--text-primary);
        }

        .stat-value.good {
            color: var(--teal);
        }

        .stat-value.warn {
            color: var(--gold);
        }

        .stat-value.bad {
            color: var(--red);
        }

        /* ─── Instructions ─────────────────────────────────────── */
        .instructions {
            font-size: 0.72rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .instructions code {
            background: var(--bg-hover);
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            font-family: var(--font-mono);
            font-size: 0.68rem;
            color: var(--text-secondary);
        }

        /* ─── Canvas Area ──────────────────────────────────────── */
        .canvas-wrap {
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #sim-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .canvas-overlay {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--text-muted);
            background: rgba(10, 10, 26, 0.8);
            padding: 0.5rem 0.75rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            pointer-events: none;
        }

        .canvas-hint {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--font-mono);
            font-size: 0.72rem;
            color: var(--text-muted);
            background: rgba(10, 10, 26, 0.85);
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* ─── Responsive ───────────────────────────────────────── */
        @media (max-width: 768px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .sidebar {
                border-right: none;
                border-bottom: 1px solid var(--border);
                max-height: 40vh;
                overflow-y: auto;
            }
        }
    </style>
</head>

<body>

    <div class="app">
        <!-- Nav -->
        <nav class="nav">
            <a href="https://gunjanlakhlani.github.io" class="nav__brand">GL</a>
            <span class="nav__title">Gravitational N-Body Simulator</span>
            <div class="nav__links">
                <a href="https://gunjanlakhlani.github.io/blog">Blog</a>
                <a
                    href="https://gunjanlakhlani.github.io/blog/2026/02/28/building-a-gravitational-nbody-solver/">About</a>
            </div>
        </nav>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Presets -->
            <div class="panel">
                <div class="panel__title">Presets</div>
                <div class="presets">
                    <button class="preset-btn" data-preset="twobody">
                        <span class="preset-icon">⊙⊙</span>
                        Two-Body
                    </button>
                    <button class="preset-btn" data-preset="figure8">
                        <span class="preset-icon">∞</span>
                        Figure-8
                    </button>
                    <button class="preset-btn" data-preset="plummer">
                        <span class="preset-icon">✦</span>
                        Cluster (50)
                    </button>
                    <button class="preset-btn" data-preset="plummer100">
                        <span class="preset-icon">✦✦</span>
                        Cluster (100)
                    </button>
                    <button class="preset-btn" data-preset="plummer1000">
                        <span class="preset-icon">⁂</span>
                        Cluster (1000)
                    </button>
                    <button class="preset-btn" data-preset="solar">
                        <span class="preset-icon">☉</span>
                        Solar System
                    </button>
                    <button class="preset-btn" data-preset="binary_star">
                        <span class="preset-icon">✶✶</span>
                        Binary Star
                    </button>
                    <button class="preset-btn" data-preset="lagrange">
                        <span class="preset-icon">△</span>
                        Lagrange
                    </button>
                </div>
            </div>

            <!-- Controls -->
            <div class="panel">
                <div class="panel__title">Controls</div>
                <div class="control-row">
                    <span class="control-label">Timestep</span>
                    <span class="control-value" id="dt-display">0.002</span>
                </div>
                <input type="range" id="dt-slider" min="-4" max="-1" step="0.1" value="-2.7">
                <div class="control-row" style="margin-top: 0.6rem;">
                    <span class="control-label">Body Mass</span>
                    <span class="control-value" id="mass-display">1.0</span>
                </div>
                <input type="range" id="mass-slider" min="-1" max="2" step="0.1" value="0">
                <div class="control-row" style="margin-top: 0.6rem;">
                    <span class="control-label">Trail Length</span>
                    <span class="control-value" id="trail-display">150</span>
                </div>
                <input type="range" id="trail-slider" min="0" max="500" step="10" value="150">
                <div class="control-row" style="margin-top: 0.6rem;">
                    <span class="control-label">Steps/Frame</span>
                    <span class="control-value" id="substep-display">4</span>
                </div>
                <input type="range" id="substep-slider" min="1" max="20" step="1" value="4">
            </div>

            <!-- Actions -->
            <div class="panel">
                <div class="panel__title">Simulation</div>
                <div class="actions">
                    <button class="btn btn--primary" id="btn-play">▶ Play</button>
                    <button class="btn" id="btn-step">⏭ Step</button>
                    <button class="btn" id="btn-reset-view">⊞ Reset View</button>
                    <button class="btn btn--danger" id="btn-clear">✕ Clear</button>
                </div>
            </div>

            <!-- Diagnostics -->
            <div class="panel">
                <div class="panel__title">Diagnostics</div>
                <div class="stat-row">
                    <span class="stat-label">Bodies</span>
                    <span class="stat-value" id="stat-bodies">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time</span>
                    <span class="stat-value" id="stat-time">0.000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Energy (E)</span>
                    <span class="stat-value" id="stat-energy">—</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">|ΔE/E₀|</span>
                    <span class="stat-value" id="stat-derror">—</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">FPS</span>
                    <span class="stat-value" id="stat-fps">—</span>
                </div>
            </div>

            <!-- Instructions -->
            <div class="panel">
                <div class="panel__title">How to Use</div>
                <div class="instructions">
                    <p><code>Click</code> on canvas to place a body</p>
                    <p><code>Click + Drag</code> to set initial velocity</p>
                    <p>Use presets for classic configurations</p>
                    <p>Adjust mass slider before placing bodies</p>
                    <p><code>Scroll</code> to zoom in/out</p>
                    <p><code>Right-click + Drag</code> to pan the view</p>
                </div>
            </div>
        </aside>

        <!-- Canvas -->
        <div class="canvas-wrap">
            <canvas id="sim-canvas"></canvas>
            <div class="canvas-overlay" id="canvas-overlay">t = 0.000</div>
            <div class="canvas-overlay" id="zoom-overlay" style="top: auto; bottom: 1rem; right: 1rem;">1.0×</div>
            <div class="canvas-hint" id="canvas-hint">Click anywhere to place a body — drag to set velocity
                &nbsp;|&nbsp; Scroll to zoom</div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════
        // Gravitational N-Body Simulator
        // Direct O(N²) pairwise force + Leapfrog (Velocity Verlet)
        // ═══════════════════════════════════════════════════════════════════

        const G = 1.0;
        const SOFTENING = 1e-4;

        // ─── Body colors ──────────────────────────────────────────────────
        const COLORS = [
            '#ff6b6b', '#4ecdc4', '#ffe66d', '#a8e6cf',
            '#ff8b94', '#6c5ce7', '#fdcb6e', '#00b894',
            '#e17055', '#74b9ff', '#fd79a8', '#55efc4',
            '#ffeaa7', '#dfe6e9', '#b2bec3', '#636e72'
        ];

        // ─── State ────────────────────────────────────────────────────────
        let bodies = [];
        let simTime = 0;
        let E0 = null;
        let running = false;
        let colorIndex = 0;
        let trailLength = 150;
        let substeps = 4;
        let dt = 0.002;
        let placingMass = 1.0;

        // Mouse interaction
        let mouseDown = false;
        let mouseStartX = 0, mouseStartY = 0;
        let mouseCurrX = 0, mouseCurrY = 0;

        // Pan interaction
        let isPanning = false;
        let panStartX = 0, panStartY = 0;

        // Zoom state
        let baseScale = 1.0; // multiplier on top of default scale
        let panX = 0, panY = 0; // pan offset in screen pixels

        // FPS tracking
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let currentFps = 0;

        // ─── Canvas setup ─────────────────────────────────────────────────
        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d');
        let W, H, scale, offsetX, offsetY;

        function resizeCanvas() {
            const wrap = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            W = wrap.clientWidth;
            H = wrap.clientHeight;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // Coordinate system: [-range, range] in both axes, centered
            const defaultScale = Math.min(W, H) / 8;
            scale = defaultScale * baseScale;
            offsetX = W / 2 + panX;
            offsetY = H / 2 + panY;
        }

        function resetView() {
            baseScale = 1.0;
            panX = 0;
            panY = 0;
            resizeCanvas();
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-overlay').textContent = baseScale.toFixed(1) + '×';
        }

        function toScreen(x, y) {
            return [x * scale + offsetX, -y * scale + offsetY];
        }

        function toSim(sx, sy) {
            return [(sx - offsetX) / scale, -(sy - offsetY) / scale];
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ─── Body class ───────────────────────────────────────────────────
        class Body {
            constructor(x, y, vx, vy, mass, color) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.ax = 0; this.ay = 0;
                this.mass = mass;
                this.color = color || COLORS[colorIndex++ % COLORS.length];
                this.trail = [];
            }
        }

        // ─── Physics engine ───────────────────────────────────────────────
        function computeForces() {
            const n = bodies.length;
            for (let i = 0; i < n; i++) {
                bodies[i].ax = 0;
                bodies[i].ay = 0;
            }
            for (let i = 0; i < n; i++) {
                let axi = 0, ayi = 0;
                for (let j = i + 1; j < n; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const r2 = dx * dx + dy * dy + SOFTENING;
                    const rInv = 1.0 / Math.sqrt(r2);
                    const r3Inv = rInv * rInv * rInv;
                    const fx = G * dx * r3Inv;
                    const fy = G * dy * r3Inv;
                    axi += bodies[j].mass * fx;
                    ayi += bodies[j].mass * fy;
                    bodies[j].ax -= bodies[i].mass * fx;
                    bodies[j].ay -= bodies[i].mass * fy;
                }
                bodies[i].ax += axi;
                bodies[i].ay += ayi;
            }
        }

        function leapfrogStep(dt) {
            const n = bodies.length;
            const hdt = 0.5 * dt;
            // Half kick
            for (let i = 0; i < n; i++) {
                bodies[i].vx += hdt * bodies[i].ax;
                bodies[i].vy += hdt * bodies[i].ay;
            }
            // Drift
            for (let i = 0; i < n; i++) {
                bodies[i].x += dt * bodies[i].vx;
                bodies[i].y += dt * bodies[i].vy;
            }
            // New forces
            computeForces();
            // Half kick
            for (let i = 0; i < n; i++) {
                bodies[i].vx += hdt * bodies[i].ax;
                bodies[i].vy += hdt * bodies[i].ay;
            }
        }

        function computeEnergy() {
            let ke = 0, pe = 0;
            const n = bodies.length;
            for (let i = 0; i < n; i++) {
                ke += 0.5 * bodies[i].mass * (bodies[i].vx ** 2 + bodies[i].vy ** 2);
            }
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const r = Math.sqrt(dx * dx + dy * dy + SOFTENING);
                    pe -= G * bodies[i].mass * bodies[j].mass / r;
                }
            }
            return ke + pe;
        }

        // ─── Recording trails ─────────────────────────────────────────────
        function recordTrails() {
            for (const b of bodies) {
                b.trail.push({ x: b.x, y: b.y });
                if (b.trail.length > trailLength) {
                    b.trail.shift();
                }
            }
        }

        // ─── Rendering ────────────────────────────────────────────────────
        function render() {
            ctx.clearRect(0, 0, W, H);

            // Background grid
            ctx.strokeStyle = 'rgba(255,255,255,0.025)';
            ctx.lineWidth = 1;
            const gridStep = scale;
            for (let gx = offsetX % gridStep; gx < W; gx += gridStep) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, H); ctx.stroke();
            }
            for (let gy = offsetY % gridStep; gy < H; gy += gridStep) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(W, gy); ctx.stroke();
            }

            // Center of mass
            if (bodies.length > 0) {
                let totalM = 0, comX = 0, comY = 0;
                for (const b of bodies) {
                    totalM += b.mass;
                    comX += b.mass * b.x;
                    comY += b.mass * b.y;
                }
                comX /= totalM; comY /= totalM;
                const [scx, scy] = toScreen(comX, comY);
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(scx - 6, scy); ctx.lineTo(scx + 6, scy);
                ctx.moveTo(scx, scy - 6); ctx.lineTo(scx, scy + 6);
                ctx.stroke();
            }

            // Trails
            for (const b of bodies) {
                if (b.trail.length < 2) continue;
                const n = b.trail.length;
                for (let i = 1; i < n; i++) {
                    const alpha = (i / n) * 0.7;
                    ctx.strokeStyle = hexToRGBA(b.color, alpha);
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    const [x1, y1] = toScreen(b.trail[i - 1].x, b.trail[i - 1].y);
                    const [x2, y2] = toScreen(b.trail[i].x, b.trail[i].y);
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }

            // Bodies
            for (const b of bodies) {
                const [sx, sy] = toScreen(b.x, b.y);
                const radius = Math.max(3, Math.min(12, 4 * Math.cbrt(b.mass)));

                // Glow
                const grd = ctx.createRadialGradient(sx, sy, 0, sx, sy, radius * 4);
                grd.addColorStop(0, hexToRGBA(b.color, 0.25));
                grd.addColorStop(1, hexToRGBA(b.color, 0));
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(sx, sy, radius * 4, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                ctx.fill();

                // White edge
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 0.8;
                ctx.stroke();
            }

            // Velocity arrow when placing
            if (mouseDown) {
                const [sx, sy] = [mouseStartX, mouseStartY];
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(mouseCurrX, mouseCurrY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Preview body
                ctx.fillStyle = COLORS[colorIndex % COLORS.length];
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(sx, sy, Math.max(3, 4 * Math.cbrt(placingMass)), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function hexToRGBA(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        // ─── UI Updates ───────────────────────────────────────────────────
        function updateStats() {
            document.getElementById('stat-bodies').textContent = bodies.length;
            document.getElementById('stat-time').textContent = simTime.toFixed(3);
            document.getElementById('canvas-overlay').textContent = `t = ${simTime.toFixed(3)}`;

            if (bodies.length >= 2) {
                const E = computeEnergy();
                document.getElementById('stat-energy').textContent = E.toExponential(4);

                if (E0 !== null && E0 !== 0) {
                    const dE = Math.abs((E - E0) / E0);
                    const el = document.getElementById('stat-derror');
                    el.textContent = dE.toExponential(2);
                    el.className = 'stat-value ' + (dE < 1e-6 ? 'good' : dE < 1e-3 ? 'warn' : 'bad');
                }
            } else {
                document.getElementById('stat-energy').textContent = '—';
                document.getElementById('stat-derror').textContent = '—';
                document.getElementById('stat-derror').className = 'stat-value';
            }

            document.getElementById('stat-fps').textContent = Math.round(currentFps);
        }

        // ─── Main loop ────────────────────────────────────────────────────
        function loop() {
            if (running && bodies.length >= 2) {
                for (let s = 0; s < substeps; s++) {
                    leapfrogStep(dt);
                    simTime += dt;
                }
                recordTrails();
            }

            render();
            updateStats();

            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime > 500) {
                currentFps = frameCount / ((now - lastFpsTime) / 1000);
                frameCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(loop);
        }

        // ─── Mouse events ─────────────────────────────────────────────────
        // ─── Zoom (mouse wheel) ────────────────────────────────────────
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // Zoom towards cursor position
            const [simX, simY] = toSim(mx, my);
            const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
            baseScale *= zoomFactor;
            baseScale = Math.max(0.05, Math.min(50, baseScale));

            // Recalculate scale and offset
            const defaultScale = Math.min(W, H) / 8;
            scale = defaultScale * baseScale;
            // Adjust pan so the point under the cursor stays fixed
            offsetX = mx - simX * scale;
            offsetY = my + simY * scale;
            panX = offsetX - W / 2;
            panY = offsetY - H / 2;

            updateZoomDisplay();
        }, { passive: false });

        // ─── Pan (right-click drag) ───────────────────────────────────────
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Right-click or middle-click = pan
            if (e.button === 2 || e.button === 1) {
                isPanning = true;
                panStartX = e.clientX - rect.left;
                panStartY = e.clientY - rect.top;
                canvas.style.cursor = 'grab';
                return;
            }
            mouseStartX = e.clientX - rect.left;
            mouseStartY = e.clientY - rect.top;
            mouseCurrX = mouseStartX;
            mouseCurrY = mouseStartY;
            mouseDown = true;
            document.getElementById('canvas-hint').style.opacity = '0';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                panX += mx - panStartX;
                panY += my - panStartY;
                panStartX = mx;
                panStartY = my;
                offsetX = W / 2 + panX;
                offsetY = H / 2 + panY;
                return;
            }
            if (!mouseDown) return;
            const rect = canvas.getBoundingClientRect();
            mouseCurrX = e.clientX - rect.left;
            mouseCurrY = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
                return;
            }

            if (!mouseDown) return;
            mouseDown = false;

            const rect = canvas.getBoundingClientRect();
            const ex = e.clientX - rect.left;
            const ey = e.clientY - rect.top;

            const [px, py] = toSim(mouseStartX, mouseStartY);
            // Velocity from drag (scaled down)
            const vScale = 2.0 / scale;
            const vx = (ex - mouseStartX) * vScale;
            const vy = -(ey - mouseStartY) * vScale;

            bodies.push(new Body(px, py, vx, vy, placingMass));

            // Reset E0 when adding bodies
            computeForces();
            E0 = computeEnergy();
        });

        // ─── Touch events ─────────────────────────────────────────────────
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseStartX = touch.clientX - rect.left;
            mouseStartY = touch.clientY - rect.top;
            mouseCurrX = mouseStartX;
            mouseCurrY = mouseStartY;
            mouseDown = true;
            document.getElementById('canvas-hint').style.opacity = '0';
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!mouseDown) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseCurrX = touch.clientX - rect.left;
            mouseCurrY = touch.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!mouseDown) return;
            mouseDown = false;

            const [px, py] = toSim(mouseStartX, mouseStartY);
            const vScale = 2.0 / scale;
            const vx = (mouseCurrX - mouseStartX) * vScale;
            const vy = -(mouseCurrY - mouseStartY) * vScale;

            bodies.push(new Body(px, py, vx, vy, placingMass));
            computeForces();
            E0 = computeEnergy();
        }, { passive: false });

        // ─── Controls ─────────────────────────────────────────────────────
        const dtSlider = document.getElementById('dt-slider');
        const massSlider = document.getElementById('mass-slider');
        const trailSlider = document.getElementById('trail-slider');
        const substepSlider = document.getElementById('substep-slider');

        dtSlider.addEventListener('input', () => {
            dt = Math.pow(10, parseFloat(dtSlider.value));
            document.getElementById('dt-display').textContent = dt.toFixed(4);
        });

        massSlider.addEventListener('input', () => {
            placingMass = Math.pow(10, parseFloat(massSlider.value));
            document.getElementById('mass-display').textContent = placingMass.toFixed(1);
        });

        trailSlider.addEventListener('input', () => {
            trailLength = parseInt(trailSlider.value);
            document.getElementById('trail-display').textContent = trailLength;
        });

        substepSlider.addEventListener('input', () => {
            substeps = parseInt(substepSlider.value);
            document.getElementById('substep-display').textContent = substeps;
        });

        // Initialize slider displays
        dt = Math.pow(10, parseFloat(dtSlider.value));
        document.getElementById('dt-display').textContent = dt.toFixed(4);

        // Play / Pause
        const btnPlay = document.getElementById('btn-play');
        btnPlay.addEventListener('click', () => {
            running = !running;
            btnPlay.textContent = running ? '⏸ Pause' : '▶ Play';
            btnPlay.className = running ? 'btn btn--danger' : 'btn btn--primary';

            if (running && E0 === null && bodies.length >= 2) {
                computeForces();
                E0 = computeEnergy();
            }
        });

        // Step
        document.getElementById('btn-step').addEventListener('click', () => {
            if (bodies.length < 2) return;
            if (E0 === null) {
                computeForces();
                E0 = computeEnergy();
            }
            for (let s = 0; s < substeps; s++) {
                leapfrogStep(dt);
                simTime += dt;
            }
            recordTrails();
        });

        // Clear
        // Reset View
        document.getElementById('btn-reset-view').addEventListener('click', resetView);

        document.getElementById('btn-clear').addEventListener('click', () => {
            bodies = [];
            simTime = 0;
            E0 = null;
            colorIndex = 0;
            running = false;
            btnPlay.textContent = '▶ Play';
            btnPlay.className = 'btn btn--primary';
            document.getElementById('canvas-hint').style.opacity = '1';
        });

        // ─── Presets ──────────────────────────────────────────────────────
        const presetBtns = document.querySelectorAll('.preset-btn');
        presetBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                loadPreset(preset);

                presetBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('canvas-hint').style.opacity = '0';
            });
        });

        function loadPreset(name) {
            bodies = [];
            simTime = 0;
            E0 = null;
            colorIndex = 0;

            switch (name) {
                case 'twobody': {
                    const d = 1.0, m = 1.0;
                    const v = Math.sqrt(G * m / (4.0 * d));
                    bodies.push(new Body(-d / 2, 0, 0, v, m));
                    bodies.push(new Body(d / 2, 0, 0, -v, m));
                    break;
                }
                case 'figure8': {
                    bodies.push(new Body(0.97000436, -0.24308753, 0.46620368, 0.43236573, 1.0));
                    bodies.push(new Body(-0.97000436, 0.24308753, 0.46620368, 0.43236573, 1.0));
                    bodies.push(new Body(0, 0, -0.93240737, -0.86473146, 1.0));
                    break;
                }
                case 'plummer': {
                    const N = 50, a = 1.0, totalMass = 10.0, mi = totalMass / N;
                    for (let i = 0; i < N; i++) {
                        let u = Math.random();
                        while (u < 1e-10) u = Math.random();
                        const r = a / Math.sqrt(Math.pow(u, -2 / 3) - 1);
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = 2 * Math.PI * Math.random();
                        const px = r * Math.sin(theta) * Math.cos(phi);
                        const py = r * Math.sin(theta) * Math.sin(phi);

                        const ve = Math.sqrt(2 * totalMass / Math.sqrt(r * r + a * a));
                        let q, fq;
                        do {
                            q = Math.random();
                            fq = Math.random();
                        } while (fq > q * q * Math.pow(1 - q * q, 3.5));
                        const v = q * ve;
                        const vphi = 2 * Math.PI * Math.random();
                        const vcostheta = 2 * Math.random() - 1;
                        const vsintheta = Math.sqrt(1 - vcostheta * vcostheta);
                        const vxp = v * vsintheta * Math.cos(vphi);
                        const vyp = v * vsintheta * Math.sin(vphi);

                        bodies.push(new Body(px, py, vxp, vyp, mi));
                    }
                    // Center-of-mass correction
                    let cx = 0, cy = 0, cvx = 0, cvy = 0, M = 0;
                    for (const b of bodies) {
                        M += b.mass;
                        cx += b.mass * b.x; cy += b.mass * b.y;
                        cvx += b.mass * b.vx; cvy += b.mass * b.vy;
                    }
                    cx /= M; cy /= M; cvx /= M; cvy /= M;
                    for (const b of bodies) {
                        b.x -= cx; b.y -= cy;
                        b.vx -= cvx; b.vy -= cvy;
                    }
                    break;
                }
                case 'plummer100': {
                    const N = 100, a = 1.2, totalMass = 20.0, mi = totalMass / N;
                    for (let i = 0; i < N; i++) {
                        let u = Math.random();
                        while (u < 1e-10) u = Math.random();
                        const r = a / Math.sqrt(Math.pow(u, -2 / 3) - 1);
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = 2 * Math.PI * Math.random();
                        const px = r * Math.sin(theta) * Math.cos(phi);
                        const py = r * Math.sin(theta) * Math.sin(phi);

                        const ve = Math.sqrt(2 * totalMass / Math.sqrt(r * r + a * a));
                        let q, fq;
                        do {
                            q = Math.random();
                            fq = Math.random();
                        } while (fq > q * q * Math.pow(1 - q * q, 3.5));
                        const v = q * ve;
                        const vphi = 2 * Math.PI * Math.random();
                        const vcostheta = 2 * Math.random() - 1;
                        const vsintheta = Math.sqrt(1 - vcostheta * vcostheta);
                        const vxp = v * vsintheta * Math.cos(vphi);
                        const vyp = v * vsintheta * Math.sin(vphi);

                        bodies.push(new Body(px, py, vxp, vyp, mi));
                    }
                    // Center-of-mass correction
                    let cx = 0, cy = 0, cvx = 0, cvy = 0, M = 0;
                    for (const b of bodies) {
                        M += b.mass;
                        cx += b.mass * b.x; cy += b.mass * b.y;
                        cvx += b.mass * b.vx; cvy += b.mass * b.vy;
                    }
                    cx /= M; cy /= M; cvx /= M; cvy /= M;
                    for (const b of bodies) {
                        b.x -= cx; b.y -= cy;
                        b.vx -= cvx; b.vy -= cvy;
                    }
                    break;
                }
                case 'plummer1000': {
                    const N = 1000, a = 2.0, totalMass = 50.0, mi = totalMass / N;
                    for (let i = 0; i < N; i++) {
                        let u = Math.random();
                        while (u < 1e-10) u = Math.random();
                        const r = a / Math.sqrt(Math.pow(u, -2 / 3) - 1);
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = 2 * Math.PI * Math.random();
                        const px = r * Math.sin(theta) * Math.cos(phi);
                        const py = r * Math.sin(theta) * Math.sin(phi);

                        const ve = Math.sqrt(2 * totalMass / Math.sqrt(r * r + a * a));
                        let q, fq;
                        do {
                            q = Math.random();
                            fq = Math.random();
                        } while (fq > q * q * Math.pow(1 - q * q, 3.5));
                        const v = q * ve;
                        const vphi = 2 * Math.PI * Math.random();
                        const vcostheta = 2 * Math.random() - 1;
                        const vsintheta = Math.sqrt(1 - vcostheta * vcostheta);
                        const vxp = v * vsintheta * Math.cos(vphi);
                        const vyp = v * vsintheta * Math.sin(vphi);

                        bodies.push(new Body(px, py, vxp, vyp, mi, COLORS[i % COLORS.length]));
                    }
                    // Center-of-mass correction
                    let cx = 0, cy = 0, cvx = 0, cvy = 0, M = 0;
                    for (const b of bodies) {
                        M += b.mass;
                        cx += b.mass * b.x; cy += b.mass * b.y;
                        cvx += b.mass * b.vx; cvy += b.mass * b.vy;
                    }
                    cx /= M; cy /= M; cvx /= M; cvy /= M;
                    for (const b of bodies) {
                        b.x -= cx; b.y -= cy;
                        b.vx -= cvx; b.vy -= cvy;
                    }
                    // Auto-adjust: zoom out, reduce trails for performance
                    baseScale = 0.5;
                    panX = 0; panY = 0;
                    resizeCanvas();
                    updateZoomDisplay();
                    trailLength = 30;
                    trailSlider.value = 30;
                    document.getElementById('trail-display').textContent = '30';
                    substeps = 2;
                    substepSlider.value = 2;
                    document.getElementById('substep-display').textContent = '2';
                    break;
                }
                case 'solar': {
                    // Simplified solar system (Sun + 4 inner planets, scaled)
                    const sunMass = 100;
                    bodies.push(new Body(0, 0, 0, 0, sunMass, '#ffe66d'));

                    const planets = [
                        { r: 0.8, m: 0.1, color: '#a0a0a0' },  // Mercury
                        { r: 1.2, m: 0.3, color: '#fdcb6e' },  // Venus
                        { r: 1.7, m: 0.4, color: '#4ecdc4' },  // Earth
                        { r: 2.3, m: 0.2, color: '#ff6b6b' },  // Mars
                    ];
                    for (const p of planets) {
                        const v = Math.sqrt(G * sunMass / p.r);
                        const angle = Math.random() * 2 * Math.PI;
                        bodies.push(new Body(
                            p.r * Math.cos(angle), p.r * Math.sin(angle),
                            -v * Math.sin(angle), v * Math.cos(angle),
                            p.m, p.color
                        ));
                    }
                    break;
                }
                case 'binary_star': {
                    // Binary star with a planet
                    const m1 = 10, m2 = 10, d = 1.5;
                    const vOrb = Math.sqrt(G * m2 / (4 * d));
                    bodies.push(new Body(-d / 2, 0, 0, vOrb, m1, '#ff6b6b'));
                    bodies.push(new Body(d / 2, 0, 0, -vOrb, m2, '#4ecdc4'));

                    // Circumbinary planet
                    const rp = 3.5, mp = 0.1;
                    const vp = Math.sqrt(G * (m1 + m2) / rp);
                    bodies.push(new Body(rp, 0, 0, vp, mp, '#ffe66d'));
                    break;
                }
                case 'lagrange': {
                    // Equilateral triangle (Lagrange configuration)
                    const m = 1.0;
                    const R = 1.0;
                    // Three bodies at vertices of equilateral triangle
                    // rotating at angular velocity omega = sqrt(3*G*m / R^3)
                    const omega = Math.sqrt(3 * G * m / (R * R * R));
                    for (let k = 0; k < 3; k++) {
                        const angle = (2 * Math.PI * k) / 3;
                        const px = R * Math.cos(angle);
                        const py = R * Math.sin(angle);
                        const vx = -omega * py;
                        const vy = omega * px;
                        bodies.push(new Body(px, py, vx, vy, m));
                    }
                    break;
                }
            }

            computeForces();
            E0 = computeEnergy();
            running = true;
            btnPlay.textContent = '⏸ Pause';
            btnPlay.className = 'btn btn--danger';
        }

        // ─── Start ────────────────────────────────────────────────────────
        requestAnimationFrame(loop);

    </script>
</body>

</html>